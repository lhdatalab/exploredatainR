---
title: "Project P4"
author: "Laura Hoyte"
date: "April 3, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the 

### Install MongoDB package for R - rmongodb

```{r  Install MongoDB package for R}

install.packages(rmongodb)
install.packages(sqldf)
install.packages(mongolite)
install.packages("devtools")
devtools::install_github("ropensci/nodbi")

library(rmongodb)
library(mongolite)
library(sqldf)
library(nodbi)

#Connect to MongoDB Database
mongo <- mongo.create(host = "127.0.0.1", name = "", db = "taxi")

#Test if connection is working
mongo.is.connected(mongo)
mongo.get.databases(mongo)
```

### Determine what one document (record) looks like in the database.

```{r Basic statistics on taxi data}

if (mongo.is.connected(mongo) == TRUE) {
  db <- "taxi"
  mongo.get.database.collections(mongo, db)
  
}
coll <- "taxi.yellowtest"
mongo.findOne(mongo, coll)

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

### MongoDB does not do random sampling with replacement by default. Therefore this was done in the original csv file using the lbrary sqldf.

```{r Random sample of 10% of yellow taxi dataset}

# Get 10% sample of yellow taxi data
rowcount <- read.csv.sql("yellow_tripdata_2015-05.csv", sql = "select count(*) from file")
yellow <- read.csv.sql("yellow_tripdata_2015-05.csv", sql = "select * from file order by random() limit 1315826")

# Write yellow sample data frame to csv file
write.csv(yellow, file = "yellow_samples.csv", quote = TRUE, na = "NA", row.names = FALSE,
          col.names = TRUE)

# Get 10% sample of green taxi data
#options(warn=3)
rowcount <- read.csv.sql("green_tripdata_2015-05.csv", sql = "select count(*) from file")

# Error when reading in data using the above - more columns than column names. Read in data only, no headers
green <- read.csv("green_tripdata_2015-05.csv", header = FALSE, stringsAsFactors =  FALSE, check.names = F, skip = 1)

# Get all of the data including header
data_and_header <- readLines("green_tripdata_2015-05.csv")

#Filter out header
headers <- strsplit(data_and_header[1], ",")[[1]]

# Add header to csv file
colnames(green) <- headers

# Drop errorneous columns
length(green)
green$"NA" <- NULL
green$"NA" <- NULL

# Check structure and length of green data frame
str(green)
length(green)

# Write green data frame to new csv file
write.csv(green, file = "green_datanew.csv", quote = TRUE, na = "NA", row.names = FALSE)

# Get 10% sample of new green taxi data
rowcount <- read.csv.sql("green_datanew.csv", sql = "select count(*) from file")
rowcount
greennew <- read.csv.sql("green_datanew.csv", sql = "select * from file order by random() limit 178685")

# Rename Trip_data column to remove "." - better for MongoDB
names(greennew)[21]<- "Trip_data"

# Write green sample data frame to csv file
write.csv(greennew, file = "green_samples.csv", quote = TRUE, na = "NA", row.names = FALSE)

# Write to new MongoDB collection yellowsample in taxi database
if (mongo.is.connected(mongo) == TRUE) {
  mongo.insert(mongo, "taxi.yellowsamples", list(yellow_bson))
}
```

## Sample data was stored in MongoDB using mongoimport

### Connect to MongoDB and get some basic statistics

```{r Connect to MongoDB and get some basic statistics}

mongoyel <- mongo(collection = "yellowsample", db = "taxi", url = "mongodb://localhost", verbose = TRUE)
mongoyel$count()
mongoyel$find('{"VendorID": 1}', limit = 1)

mongogr <- mongo(collection = "greensample", db = "taxi", url = "mongodb://localhost", verbose = TRUE)
mongogr$count()
mongogr$find('{"VendorID": 1}', limit = 1)
```

Number of rows in yellowsample
1315826
 
Number of rows in greensample
178685

### Plot histograms of total_amount for taxi ride - yelow and green

```{r Plot histograms of total_amount for taxi ride}

library(gridExtra)
library(ggplot2)

summary(yellow$total_amount)
ggplot(aes(x = total_amount), data = yellow) +
  geom_histogram(binwidth = 1, fill = I("#DED20E")) +
  scale_x_continuous(breaks = seq(-200, 1000, 100)) +
  ggtitle("Distribution of Yellow Taxi Total Fare")

ggsave("sample/total_fare_hist_y.jpg")

summary(greennew$Total_amount)
ggplot(aes(x = Total_amount), data = greennew) +
  geom_histogram(binwidth = 1, fill = I("#5BC70C")) +
  scale_x_continuous(limits = c(-100, 1000), breaks = seq(-100, 1000, 100)) +
  ggtitle("Distribution of Green Taxi Total Fare")

ggsave("sample/total_fare_hist_g.jpg")

```

### Boxplot of total_amount by payment type
There seems to be outliers in the data as most of it ins concentraated between $0 to $100 for both taxi types. Use a boxplot to show where these outliers are located in relation to the median value.
Plot total_amount vs. payment_type

```{r Boxplot of total_amount for taxi ride by payment type}

# YELLOW
fpayment <- factor(yellow$payment_type, labels = c("Credit Card", "Cash", "No charge", "Dispute"))
options (warn = 1)

ggplot(aes(x = fpayment, y = total_amount), data = yellow) +
  geom_boxplot(fill =  "white", color = I("#DED20E"), outlier.color = "blue") +
  ggtitle("Yellow Taxi: Summary distribution of Total Fare by Payment Type") +
  coord_cartesian(ylim = c(-20, 100))

ggsave("sample/totalpay_bypaytype.jpg")

by(yellow$total_amount, fpayment, summary)

# GREEN
fpayment <- factor(greennew$Payment_type, labels = c("Credit Card", "Cash", "No charge", "Dispute", "Unknown"))
options (warn = 1)

ggplot(aes(x = fpayment, y = Total_amount), data = greennew) +
  geom_boxplot(fill =  "white", color = I("#5BC70C"), outlier.color = "blue") +
  ggtitle("Green Taxi: Summary distribution of Total Fare by Payment Type") +
  coord_cartesian(ylim = c(-120, 100))

ggsave("sample/totalpay_bypaytypegr.jpg")

by(greennew$total_amount, greennew$Payment_type, summary)
  

```


### Test mongolite package
## Connect to MongoDB and get some basic statistics

```{r Test mongolite package}

mongoyel <- mongo(collection = "yellow", db = "taxi", url = "mongodb://localhost", verbose = TRUE)
mongoyel$count()
mongoyel$find('{"VendorID": 1}', limit = 1)

green <-mongogrn <- mongo(collection = "green", db = "taxi", url = "mongodb://localhost", verbose = TRUE)
mongogrn$count()
mongogrn$find('{"VendorID": 1}', limit = 1)
test <- mongogrn$find('{}', fields = '{"_id":0, "Ehail_fee":1, "field21": 1, "field22": 1}')

mongogrn$update('{}', update = '{"$unset": {"Ehail_fee":"", "field21":"", "field22":""}}', multiple = TRUE)

```


### Change green column names to lowercase and rename and simplify field names 
We want both colections to have the same field names

```{r Change field names}

library(dplyr)
library(mongolite)
library(nodbi)

mongoyel$find('{"VendorID": 1}', limit = 1)
mongoyel$update('{}', update = '{"$rename": {"VendorID":"vendorid", "RateCodeID":"ratecodeid"}}', multiple = TRUE)

colsyel <- mongoyel$find('{"VendorID": 1}', limit = 1)



src <- src_mongo(url = "mongodb://localhost", db = "taxi")

# Get list of column names for green table
docdb_create(src, key = "green2", value = green)
greentbl <- docdb_get(src)
  #sample_n(1, replace = TRUE)

greentbl <- src %>%
  tbl("green") %>%
  slice(1:2)
  

# Columns to change to lowercase
columns <- list("VendorID", "RateCodeID")


docdb_get(src, "taxi.yellow") %>%
  rename(vendorid = VendorID) %>%
  rename(ratecodeid = RateCodeID)



```



### Read all yellow and green data for May into data frames and test for sparse payment_type values

```{r Test for payment_type = Dispute, Unknown and Voided trip}

yellowall <- read.csv()


```


### Cannot find a way to use nodbi without loading all 13 million rows in yellow collection

### Pivot plan and do the following
## Part 1

# 1. Create index on date - both yellow and green tables
# 2. Select rows where pickup times lie between May 24th, 2015, 12:00:00am and May 31, 2015 11:59:59pm

## Part 2

# 1. Load library lubridate
# 2. Create week, month, year, day, day of the week (dow), weekend/weekday, hour, minute, second columns. Fill with empty character strings
# 3. Create index on date
# 4. Write funtion to do the following
    a. Get each date from yellow collection
    b. Create week, month, yeasr etc. using lubridate
    c. set type = yellow or green
    d. Update document or row with the new columns

```{r}
library(data.table)

# Connect to both collections and test connection
mongoyel <- mongo(collection = "yellow", db = "taxi", url = "mongodb://localhost", verbose = TRUE)
mongoyel$count()
mongoyel$find('{"VendorID": 1}', limit = 1)
test <- mongoyel$find('{}', fields ='{"_id":0, "tpep_pickup_datetime": 1}', limit = 5) #  sort ='{"tpep_pickup_datetime":- 1}', limit = 5)


mongogrn <- mongo(collection = "green", db = "taxi", url = "mongodb://localhost", verbose = TRUE)
mongogrn$count()
mongogrn$find('{"VendorID": 1}', limit = 1)

#gr <- mongogrn$find('{"lpep_pickup_datetime": 
                    #{"$gte": "2015-05-24 00:00:00", "$lte": "2015-05-31 23:59:59" }}')

gr <- mongogrn$find('{"lpep_pickup_datetime": 
                    {"$gte": "2015-05-29 00:00:00", "$lte": "2015-05-29 23:59:59" }}')

grtbl <- data.table(gr)

yel <- mongoyel$find('{"tpep_pickup_datetime": 
                    {"$gte": "2015-05-29 00:00:00", "$lte": "2015-05-29 23:59:59" }}')

yeltbl <- data.table(yel)

yelday <- yel
grnday <-  gr
rm(yel)
rm(gr)

```

### Use lubridate to convert character dates to datetime values

```{r Convert to datetime using lubridate}

library(lubridate)
library(dplyr)
library(nodbi)
library(mongolite)

src <- src_mongo(url = "mongodb://localhost", db = "taxi")

# GStore last wwek in May data in MongoDB
docdb_create(src, key = "greenweek", value = grtbl)
greentbl <- docdb_get(src, "greenweek")

grnwkd <- subset(grtbl, grtbl$lpep_pickup_datetime >= "2015-05-29 00:00:00" & grtbl$lpep_pickup_datetime <= "2015-05-31 23:59:59")

grnday <- subset(grtbl, grtbl$lpep_pickup_datetime >= "2015-05-29 00:00:00" & grtbl$lpep_pickup_datetime <= "2015-05-29 23:59:59")

# Get all date columns from grntbl and yeltbl
gdatecols <- grnday %>%
            select(contains("datetime"))

changetodate <- function(chardate, pref) {
  #pckdate = vector("list", 8)
  dimdate = dim(grnday)[1]
  getdate <- data.frame(numeric(0), numeric(0), numeric(0), numeric(0), numeric(0), numeric(0), numeric(0), numeric(0), numeric(0))
  getdate[dimdate,] <- 0
  pref <- "pck"
  colnames(getdate) <- c(paste0(pref, "datetime"), paste0(pref,"year"), paste0(pref,"month"), paste0(pref,"day"), paste0(pref,"hour"), paste0(pref,"minute"), paste0(pref,"second"), paste0(pref,"yday"), paste0(pref, "wday"))
  #y <- colnames(getdate)
  #names(z) <- paste0(pref, "datetime")
  getdate[,1] <- ymd_hms(grnday$lpep_pickup_datetime, tz = "America/New_York")
  getdate[,2] <- year(getdate[,1])
  getdate[,3] <- month(getdate[,1])
  getdate[,4] <- day(getdate[,1])
  getdate[,5] <- hour(getdate[,1])
  getdate[,6] <- minute(getdate[,1])
  getdate[,7] <- second(getdate[,1])
  getdate[,8] <- yday(getdate[,1])
  getdate[,9] <- wday(getdate[,1])
  
  head(getdate, 10)
  
}

x <- new_dates <- changetodate(grnday$lpep_pickup_datetime, "pck")



```

### Change of plans use 10% sample data instead

```{r 10% sample data - change date fields}

library(lubridate)
library(dplyr)
library(nodbi)
library(mongolite)

#mongogrn <- mongo(collection = "greensample", db = "taxi", url = "mongodb://localhost", verbose = TRUE)
#mongogrn$count()
#mongogrn$find('{"VendorID": 1}', limit = 1)

grndata <- mongogrn$find('{}')

mongogrnday <- mongo(collection = "green", db = "taxi", url = "mongodb://localhost", verbose = TRUE)
mongogrnday$count()
mongogrnday$find('{"VendorID": 1}', limit = 1)

grnday <-  mongogrnday$find('{"lpep_pickup_datetime": {"$gte": "2015-05-29 00:00:00", "$lte": "2015-05-29 11:59:59"}}')

#mongoyel <- mongo(collection = "yellowsample", db = "taxi", url = "mongodb://localhost", verbose = TRUE)
#mongoyel$count()
#mongoyel$find('{"VendorID": 1}', limit = 1)

yeldata <- mongoyel$find('{}')

mongoyelday <- mongo(collection = "yellow", db = "taxi", url = "mongodb://localhost", verbose = TRUE)
mongoyelday$count()
mongoyelday$find('{"VendorID": 1}', limit = 1)

yelday <-  mongoyelday$find('{"tpep_pickup_datetime": {"$gte": "2015-05-29 00:00:00", "$lte": "2015-05-29 11:59:59"}}')

```


### Change date information using dplyr and lubridate

```{r change dates}

# change column names to lower case
colnames(grnday) <- tolower(colnames(grnday))
grndatecols <- grnday %>%
            select(contains("datetime"))

colnames(yelday) <- tolower(colnames(yelday))
yeldatecols <- yelday %>%
            select(contains("datetime"))

chardate = yeldatecols$tpep_pickup_datetime

changetodate <- function(chardate, pref) {
  #pckdate = vector("list", 8)
  dimdate = length(chardate)
  getdate <- data.frame(numeric(0), numeric(0), numeric(0), numeric(0), numeric(0), numeric(0), numeric(0), numeric(0), numeric(0))
  getdate[dimdate, 9] <- 0
  #pref <- "pck"
  colnames(getdate) <- c(paste0(pref, "datetime"), paste0(pref,"year"), paste0(pref,"month"), paste0(pref,"day"), paste0(pref,"hour"), paste0(pref,"minute"), paste0(pref,"second"), paste0(pref,"yday"), paste0(pref, "wday"))
  #y <- colnames(getdate)
  #names(z) <- paste0(pref, "datetime")
  getdate[,1] <- ymd_hms(chardate, tz = "America/New_York")
  getdate[,2] <- year(getdate[,1])
  getdate[,3] <- month(getdate[,1])
  getdate[,4] <- day(getdate[,1])
  getdate[,5] <- hour(getdate[,1])
  getdate[,6] <- minute(getdate[,1])
  getdate[,7] <- second(getdate[,1])
  getdate[,8] <- yday(getdate[,1])
  getdate[,9] <- wday(getdate[,1])
  
  getdate
  
}

gnew_pckdates <- changetodate(grndatecols$lpep_pickup_datetime, "pck")
gnew_dropdates <- changetodate(grndatecols$lpep_dropoff_datetime, "drp")

gnew <- bind_cols(gnew_pckdates, gnew_dropdates)

ynew_pckdates <- changetodate(yeldatecols$tpep_pickup_datetime, "pck")
ynew_dropdates <- changetodate(yeldatecols$tpep_dropoff_datetime, "drp")

ynew <- bind_cols(ynew_pckdates, ynew_dropdates)

```


### Rename columns of yellow and green taxi data

```{r Rename columns to match}

# Rename columns in both data frames to match
yelday <-  yelday %>%
                    rename(pickup_datetime = tpep_pickup_datetime, dropoff_datetime = tpep_dropoff_datetime)

grnday <-  grnday %>%
                    rename(pickup_datetime = lpep_pickup_datetime, dropoff_datetime = lpep_dropoff_datetime)

# Create column in yellow taxi data frame called trip_type and populate with 0
yelday$trip_type <- 0

# Create column in yellow and green taxi data frames called type and popu;ate with yellow and green respectively for the type of taxi.

yelday$type <- "yellow"
grnday$type <- "green"

```

### Combine new times series colums and yellow and greeen taxi rows to form one data frame

```{r Combine yellow and green taxi data frames}

# Add new columns to yellow and green taxi data frame
yeldata <- bind_cols(yelday, ynew)
grndata <- bind_cols(grnday, gnew)

# Combine yellow and green taxi data to form one data frame
taxidata <- bind_rows(yeldata, grndata)

# Create id column in taxidata data.frame
dim(taxidata)
id <- 1:dim(taxidata)[1]

taxidata$id <- id

```

### Write taxi data into MongoDB

```{r Write taxidata into MongoDB}

library(jsonlite)

# Convert taxi data into JSON format

#writeLines (taxiJSON, "taxiday.ndjson")

alltaxiday <- mongo(collection = "taxi0529", db = "taxi", url = "mongodb://localhost", verbose = TRUE)
stream_out(taxidata, file("taxi0529.ndjson"), pagesize = 1000)
alltaxiday$import(file("taxi0529.ndjson"), bson = FALSE)

test <- alltaxiday$find('{}')

```

